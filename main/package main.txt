package main

import (
	"fmt"
	"math/rand"
	"net/http"
	"os"
	"text/template"
	"piscine"
)

type Test struct {
	Att  int
	Word string
	Jose string
	Rep  []string
	Win  []piscine.Score
}

const port = ":8080"

var attempt int
var UdScore []rune
var pick string
var boolean = true
var rep []string
var Name string
var level string
var winners []piscine.Score

type Score struct {
	Name   string
	Points int
}

func Redirect(w http.ResponseWriter, r *http.Request) {
	if boolean {
		boolean = false
		http.Redirect(w, r, "/hangman", http.StatusSeeOther)
	} else {
		new := Test{Att: attempt, Word: string(UdScore), Jose: piscine.check(attempt, UdScore, pick), Rep: rep}
		tmpl := template.Must(template.ParseFiles("./tmpl/index.html"))
		tmpl.Execute(w, new)
	}
}

func main() {
	http.HandleFunc("/", Redirect)

	http.HandleFunc("/home", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./tmpl/home.html")
	})

	http.HandleFunc("/accueil", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./tmpl/accueil.html")
	})

	http.HandleFunc("/win", func(w http.ResponseWriter, r *http.Request) {
		boolean = true

		if level == "EASY" {
			winners = append(winners, piscine.Score{Name: Name, Points: attempt})
		} else if level == "NORMAL" {
			winners = append(winners, piscine.Score{Name: Name, Points: attempt * 2})
		} else {
			winners = append(winners, piscine.Score{Name: Name, Points: attempt * 3})
		}
		winners = piscine.ScoreJoueur(winners)
		new := Test{Win: winners}
		tmpl := template.Must(template.ParseFiles("./tmpl/win.html"))
		tmpl.Execute(w, new)
	})

	http.HandleFunc("/loose", func(w http.ResponseWriter, r *http.Request) {
		boolean = true
		new := Test{Word: pick}
		tmpl := template.Must(template.ParseFiles("./tmpl/loose.html"))
		tmpl.Execute(w, new)
	})

	http.HandleFunc("/hangman2", func(w http.ResponseWriter, r *http.Request) {
		if err := r.ParseForm(); err != nil {
			fmt.Fprintf(w, "ParseForm() err: %v", err)
			return
		}

		letter := piscine.ToUpper(r.Form.Get("field2"))
		deja := true
		for i := range rep {
			if rep[i] == letter {
				deja = false
			}
		}

		udd := attempt
		UdScore, attempt = piscine.Compare(UdScore, attempt, pick, letter)
		if deja && udd != attempt {
			rep = append(rep, letter)
		}

		if attempt <= 0 && r.Method == "POST" {
			boolean = true
			http.Redirect(w, r, "/loose", http.StatusSeeOther)
		}
		if string(UdScore) == pick && r.Method == "POST" {
			boolean = true
			http.Redirect(w, r, "/win", http.StatusSeeOther)
		}

		http.Redirect(w, r, "/", http.StatusSeeOther)
	})

	http.HandleFunc("/hangman", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./tmpl/hangman.html")
	})

	http.HandleFunc("/choix", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/", http.StatusSeeOther)

		UdScore = []rune{}
		if len(os.Args) == 1 {
			if err := r.ParseForm(); err != nil {
				fmt.Fprintf(w, "ParseForm() err: %v", err)
				return
			}
			rep = []string{}
			piscine.Repetition = []string{}
			level = r.Form.Get("w")
			pick = piscine.ToUpper(piscine.Random(level))
			Name = r.Form.Get("nom_utilisateur")
			attempt = 10

			for range pick {
				UdScore = append(UdScore, '_')
			}

			for v := 0; v < len(pick)/2-1; v++ {
				random := rand.Intn(len(pick))
				if UdScore[random] == '_' {
					UdScore[random] = rune(pick[random])
				} else {
					v--
				}
			}
		}

		http.Redirect(w, r, "/", http.StatusSeeOther)
	})

	//Show #CSS
	//fs := http.FileServer(http.Dir("./static"))
	//http.Handle("/static/", http.StripPrefix("/static/", fs))
	http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static"))))
	http.Handle("/images/", http.StripPrefix("/images/", http.FileServer(http.Dir("images"))))

	fmt.Println("\n(http://localhost:8080/home) - Server started on port", port)
	http.ListenAndServe(port, nil)
}